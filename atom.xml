<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://github.com/pumkinpie/pumkinpie.github.io</id>
    <title>PumpkinPie&apos;s blog</title>
    <updated>2019-09-27T08:07:57.020Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://github.com/pumkinpie/pumkinpie.github.io"/>
    <link rel="self" href="https://github.com/pumkinpie/pumkinpie.github.io/atom.xml"/>
    <subtitle>有趣的你，发现了这里</subtitle>
    <logo>https://github.com/pumkinpie/pumkinpie.github.io/images/avatar.png</logo>
    <icon>https://github.com/pumkinpie/pumkinpie.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, PumpkinPie&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[秒杀系统设计-李云华-极客时间]]></title>
        <id>https://github.com/pumkinpie/pumkinpie.github.io/post/LhWMmvT6n</id>
        <link href="https://github.com/pumkinpie/pumkinpie.github.io/post/LhWMmvT6n">
        </link>
        <updated>2019-04-21T07:17:22.000Z</updated>
        <content type="html"><![CDATA[<p>秒杀系统设计-李云华-极客时间</p>
<h2 id="设计系统-5-个-结构原则">设计系统- 5 个 结构原则</h2>
<h3 id="架构原则4-要-1-不要">架构原则：4 要 1 不要</h3>
<h3 id="1请求数据-要尽量少减少-cpu-消耗">1，请求数据 要尽量少，减少 CPU 消耗</h3>
<p>WHY？</p>
<ul>
<li>首先，这些数据在网络上传输需要时间，其次不管是请求数据还是返回许哟啊都需要服务器做处理，而故武器在写网络时通常要做压缩和字符编码，很消耗 CPU。</li>
<li>其次，完成某些业务逻辑需要读取和存储数据，需要与后台服务以及数据库打交道。调用其他服务会涉及数据的序列化和反序列化，大大消耗 CPU，也会增加延迟。</li>
</ul>
<p>HOW？</p>
<ul>
<li>简化秒杀页面的大小，也掉不必要的页面装修效果。</li>
<li>数据越简单、越小越好。</li>
</ul>
<h3 id="2减少额外请求减少加载时间">2，减少额外请求，减少加载时间</h3>
<p>WHY？</p>
<p>渲染页面需要其他的额外请求。</p>
<p>做三次握手。</p>
<p>请求不同域名，涉及 DNS 解析。</p>
<p>HOW？</p>
<p>减少请求数。常用：合并 CSS 和 JavaScript 文件，多个 JavaScript  文件合并成一个文件，在 URL 中用 逗号隔开。</p>
<h3 id="3访问路径尽量短减少节点消耗">3，访问路径尽量短，减少节点消耗</h3>
<p>路径：用户请求发出请求到返回数据这个过程中，需求经过的中间的节点数。</p>
<p>WHY？</p>
<p>每经过一个节点，一般都会产生一个新的 Socket 连接。</p>
<p>每增加一个节点，会增加新的不确定性。</p>
<p>HOW？</p>
<p>减少中间节点，减少网络传输耗时。</p>
<p>多个相互强依赖应用合并部署在一起。</p>
<h3 id="4强依赖尽量少减少加载时间">4，强依赖尽量少，减少加载时间</h3>
<p>依赖：完成一次用户请求必须依赖的系统或者服务，指 强依赖。</p>
<p>WHY？</p>
<p>非要不可信息（弱连接），非紧急情况可以去掉。</p>
<p>HOW？</p>
<p>给系统分级，O 级，1 级...</p>
<p>PS：0 级系统要尽量减少对 1 级系统的强依赖。</p>
<h3 id="5不要有单点要有备份">5，不要有单点，要有备份</h3>
<p>WHY？</p>
<p>单点意味没有备份，风险不可控。</p>
<p>HOW？</p>
<p>如果避免单点：避免将服务的状态和机器绑定，把服务无状态化，这样服务就可以在机器中随机移动。</p>
<p>如何把服务的状态和机器解耦？把和机器的配置动态化，这些参数可以通过配置中心来动态推送，在服务启动时拉取，可以在这些配置中心设置一些规则来方便改变映射关系。</p>
<p>架构是一种平衡的艺术，最好的架构一旦脱离了它所适应的场景，一切都将是空谈。</p>
<h2 id="如何做好动静分离">如何做好动静分离？</h2>
<p>秒杀的场景 中，对于系统的要求其实就三个字：快、准、稳。</p>
<h3 id="何为动静数据">何为动静数据？</h3>
<ul>
<li>“动态数据”和“静态数据”的主要区别：看⻚⾯中输出的数据是否和 URL、浏览 者、时间、地域相关，以及是否含有 Cookie 等私密数据。</li>
<li>数据中是否含有和访问者相关的个性化数据。</li>
</ul>
<p>PS：⻚⾯中“不包含”，指的是“⻚⾯的 HTML 源码中不含有</p>
<h3 id="怎样对静态数据做缓存呢">怎样对静态数据做缓存呢？</h3>
<p>第⼀，你应该把静态数据缓存到离⽤户最近的地⽅。</p>
<p>缓存到哪⾥呢？常⻅的就三种，⽤户浏览器⾥、CDN 上或者在服 务端的 Cache 中。</p>
<p>第⼆，静态化改造就是要直接缓存 HTTP 连接。</p>
<p>静态化改造是直接缓存 HTTP 连接⽽不是仅仅缓存数据。</p>
<p>第三，让谁来缓存静态数据也很重要。</p>
<p>不同语⾔写的 Cache 软件处理缓存数据的效率也各不相 同。</p>
<h3 id="如何做动静分离的改造">如何做动静分离的改造？</h3>
<p>如何把动态⻚⾯改造 成适合缓存的静态⻚⾯呢？</p>
<p>从以下 5 个⽅⾯来分离出动态内容：</p>
<ul>
<li>
<p>1，URL 唯⼀化。</p>
<p>为啥要 URL 唯⼀呢？是要缓存整个 HTTP 连接，那么以什么作为 Key 呢？就以 URL 作为缓存的 Key，例如以 id=xxx 这个格式进⾏区分。</p>
</li>
<li>
<p>2，分离浏览者相关的因素。</p>
<p>浏览者相关的因素包括是否已登录，以及登录身份等</p>
</li>
<li>
<p>3，分离时间因素。</p>
<p>服务端输出的时间也通过动态请求获取。</p>
</li>
<li>
<p>4，异步化地域因素。</p>
<p>详情⻚⾯上与地域相关的因素做成异步⽅式获取。（可以使用动态，但异步更合适）</p>
</li>
<li>
<p>5，去掉 Cookie。</p>
<p>服务端输出的⻚⾯包含的 Cookie 可以通过代码软件来删除。</p>
</li>
</ul>
<p>PS：去掉 Cookie 并不是⽤户端收到的⻚⾯就不含 Cookie 了，⽽是说，在缓存的静态数据中不含有 Cookie。</p>
<p>再，因为这其 中很多动态内容都会被⻚⾯中的其他模块⽤到，如判断该⽤户是否已登录、⽤户 ID 是否匹配 等，所以这个时候我们应该将这些信息 JSON 化（⽤ JSON 格式组织这些数据），以⽅便前端 获取。</p>
<p>动态内容的处理通常有两种⽅案：ESI（Edge Side Includes）⽅案， CSI（Client Side Include）⽅案。</p>
<ul>
<li>
<p>1，ESI ⽅案（或者 SSI）：即在 Web 代理服务器上做动态内容请求，并将请求插⼊到静态⻚ ⾯中，当⽤户拿到⻚⾯时已经是⼀个完整的⻚⾯了。</p>
<p>这种⽅式对服务端性能有些影响，但是 ⽤户体验较好。</p>
</li>
<li>
<p>2，CSI ⽅案。即单独发起⼀个异步 JavaScript 请求，以向服务端获取动态内容。</p>
<p>这种⽅式服 务端性能更佳，但是⽤户端⻚⾯可能会延时，体验稍差。</p>
</li>
</ul>
<h3 id="动静分离的几种架构方案">动静分离的⼏种架构⽅案</h3>
<p>有 3 种⽅案可选：</p>
<ul>
<li>
<p>1，实体机单机部署；</p>
<p>HOW？</p>
<p>这种⽅案是将虚拟机改为实体机，以增⼤ Cache 的容量，并且采⽤了⼀致性 Hash 分组的⽅式 来提升命中率。</p>
<p>将 Cache 分成若⼲组，是希望能达到命中率和访问热点的平衡。</p>
<p>WHY？</p>
<p>Hash 分 组越少，缓存的命中率肯定就会越⾼，但短板是也会使单个商品集中在⼀个分组中，容易导致 Cache 被击穿，所以我们应该适当增加多个相同的分组，来平衡访问热点和命中率的问题。</p>
<p>有以下⼏个优点：</p>
<ul>
<li>
<p>1，没有⽹络瓶颈，⽽且能使⽤⼤内存；</p>
</li>
<li>
<p>2，既能提升命中率，⼜能减少 Gzip 压缩；</p>
</li>
<li>
<p>3，减少 Cache 失效压⼒，因为采⽤定时失效⽅式，例如只缓存 3 秒钟，过期即⾃动失效。</p>
</li>
</ul>
<p>优势很明显，它 会增加单机的内存容量，但是⼀定程度上也造成了 CPU 的浪费。</p>
<p>⼀个实体机上部署了 Java 应⽤⼜作为 Cache 来使⽤，这造成了运维上的高复杂 度，所以这是⼀个折中的⽅案。</p>
</li>
<li>
<p>2，统⼀ Cache 层；</p>
<p>将单机的 Cache 统⼀分离出来，形成⼀个单独的 Cache 集群。统⼀ Cache 层是个更理想的可推⼴⽅案。</p>
<p>将 Cache 层单独拿出来统⼀管理可以减少运维成本，同时也⽅便接⼊其他静态化系统。</p>
<p>有⼀些优点：</p>
<ul>
<li>
<p>1，单独⼀个 Cache 层，可以减少多个应⽤接⼊时使⽤ Cache 的成本。只要 维护⾃⼰的 Java 系统就好，不需要单独维护 Cache，⽽只关⼼如何使⽤即可。</p>
</li>
<li>
<p>2，统⼀ Cache 的⽅案更易于维护。只需要⼀套解决⽅案就 ⾏，统⼀起来维护升级也⽐较⽅便。</p>
</li>
<li>
<p>3，可以共享内存，最⼤化利⽤内存，不同系统之间的内存可以动态切换，从⽽能够有效应对各 种攻击。</p>
</li>
</ul>
<p>存在问题：</p>
<ul>
<li>
<p>1，Cache 层内部交换⽹络成为瓶颈；</p>
</li>
<li>
<p>2，缓存服务器的⽹卡也会是瓶颈；</p>
</li>
<li>
<p>3，机器少⻛险较⼤，挂掉⼀台就会影响很⼤⼀部分缓存数据。</p>
</li>
</ul>
<p>要解决：可以再对 Cache 做 Hash 分组，即⼀组 Cache 缓存的内容相同，这样 能够避免热点数据过度集中导致新的瓶颈产⽣。</p>
</li>
<li>
<p>3，上 CDN。</p>
<p>将 Cache 进⼀步前移到 CDN 上，因为 CDN 离⽤户最近，效果会更好。</p>
<p>⼏个问题需要解决：</p>
<ul>
<li>
<p>1，失效问题。需要保证 CDN 可以在秒级时间内，让分布在全国各地的 Cache 同时失效，这对 CDN 的失效系统要求很 ⾼。</p>
</li>
<li>
<p>2，命中率问题。如果将数据全部放到全国的 CDN 上，必然导致 Cache 分散。 Cache 分散 ⼜会导致访问请求命中同⼀个 Cache 的可能性降低，那么命中率就成为⼀个问题。</p>
</li>
<li>
<p>3，发布更新问题。如果⼀个业务系统每周都有⽇常业务需要发布，那么发布系统必须⾜够简洁 ⾼效，⽽且你还要考虑有问题时快速回滚和排查问题的简便性。</p>
</li>
</ul>
<p>是否可以选择若⼲个节点来尝试实施呢？</p>
<p>节点需要满⾜⼏个条件：</p>
<p>1，靠近访问量⽐较集中的地区；</p>
<p>2，离主站相对较远；</p>
<p>3，节点到主站间的⽹络⽐较好，⽽且稳定；</p>
<p>4，节点容量⽐较⼤，不会占⽤其他 CDN 太多的资源。节点不要太多。</p>
<p>综上，选择 CDN 的⼆级 Cache ⽐较合适，因为⼆级 Cache 数量偏少，容量也更 ⼤，让⽤户的请求先回源的 CDN 的⼆级 Cache 中，如果没命中再回源站获取数据</p>
<p>使⽤ CDN 的⼆级 Cache 作为缓存，可以达到和当前服务端静态化 Cache 类似的命中率</p>
<p>CDN 化部署⽅案还有以下⼏个特点：</p>
<p>1，把整个⻚⾯缓存在⽤户浏览器中；</p>
<p>2，如果强制刷新整个⻚⾯，也会请求 CDN；</p>
<p>3，实际有效请求，只是⽤户对“刷新抢宝”按钮的点击。</p>
<p>这样就把 90% 的静态数据缓存在了⽤户端或者 CDN 上，当真正秒杀时，⽤户只需要点击特殊 的“刷新抢宝”按钮，⽽不需要刷新整个⻚⾯。</p>
<p>这样⼀来，系统只是向服务端请求很少的有效数 据，⽽不需要重复请求⼤量的静态数据。</p>
</li>
</ul>
<h3 id="总结一下">总结⼀下</h3>
<p>存储在浏览器或 CDN 上，有多⼤区别？区别很⼤！</p>
<p>因为在 CDN 上，我们可以做主动失效，⽽在⽤户的浏览器⾥就更不可控，如果⽤户不主动刷新的话，你很难 主动地把消息推送给⽤户的浏览器。</p>
<p>在什么地⽅把静态数据和动态数据合并并渲染出⼀个完整的⻚⾯也很关键！</p>
<p>如果在服务端合并的话，就要 考虑缓存的数据是否进⾏ Gzip 压缩了：如果缓存 Gzip 压缩后的静态数据可以减少缓存的数据 量，但是进⾏⻚⾯合并渲染时就要先解压，然后再压缩完整的⻚⾯数据输出给⽤户；如果缓存未 压缩的静态数据，这样不⽤解压静态数据，但是会增加缓存容量。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络-复习版]]></title>
        <id>https://github.com/pumkinpie/pumkinpie.github.io/post/computer_network</id>
        <link href="https://github.com/pumkinpie/pumkinpie.github.io/post/computer_network">
        </link>
        <updated>2019-04-17T12:11:57.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="计算机网络">计算机网络</h1>
<p>[TOC]</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="计算机网络">计算机网络</h1>
<p>[TOC]</p>
<!-- more -->
<h2 id="五层协议">五层协议</h2>
<p>中和 OSI 和 TCP/IP 的优点，采用 只有 五层协议的体系结构。</p>
<h3 id="应用层">应用层</h3>
<p>任务：通过应用程序的交互来完成特定任务的应用。</p>
<p>定义：应用进程间的通信 和 交互的规则。</p>
<p>不同的网络应用需要不同的应用层协议。</p>
<p>应用层交互数据的数据单元称为 报文。</p>
<p>协议：HTTP，DNS，SMTP</p>
<p>设计 HTTP 原因：提供一种可以发送和接收 HTML 文本的方法</p>
<h3 id="运输层">运输层</h3>
<p>任务：向 两台主机之间提供通用的数据传输服务。应用进程使用该该服务传输应用层报文。<br>
运输层分为：复用，分用。</p>
<ul>
<li>
<p>复用：多个运输层的进程可以使用下面的运输层的服务。</p>
</li>
<li>
<p>分用：运输层收到的信息分别交付给上面应用层的相应进程。</p>
<p>主要协议：UDP，TCP</p>
<p>UDP：无连接，尽最大努力交付，面向报文，没有拥塞控制，支持一对一，一对多，多对多，多对一，首部开销小。</p>
<p>TCP：面向连接，通信前需要确认，只能存在两个端点，提供一种可靠的交付服务，提供双全工通信，面向字节流。TCP 把应用程序下来的数据仅仅看作一串无结构的字节流。</p>
</li>
</ul>
<h3 id="网络层">网络层</h3>
<p>任务：选择合适的路由 和 交换节点，确保数据及时传输。</p>
<p>发送数据时，网络层把 运输层产生的报文段 或 用户数据报封装成 分组 和  包 进行传递。</p>
<p>网路网络层使用 IP 协议。分组可叫 IP 数据报，数据报。</p>
<p>注意：网络层 中的网路特指，网络通信模型中的网络；互联网使用的网络层协议：无连接的网际协议，许多路由选择协议。</p>
<p>网络层 亦称 IP 层，忘记层。</p>
<h3 id="数据链路层">数据链路层</h3>
<p>任务：节点在进行传输数据时，数据链路层把网路层交付的数据报 封装成 帧，在节点之间的链路上传送。</p>
<p>每一帧包括必要的 数据 和 必要的控制信息。</p>
<p>控制信息的作用：</p>
<p>1，接收数据，知道 一个帧 从哪开始，哪结束。可以更好的截取数据，交给网络层。</p>
<p>2，检测帧有无差错。存在差错，直接抛弃，避免浪费资源。</p>
<p>3，改正数据在链路层传输时出现差错，采用可靠性传输协议来纠正。数据链路层要检错，而且还要纠错</p>
<h3 id="物理层">物理层</h3>
<p>任务：实现相邻计算机之间比特流的透明传送，尽可能 屏蔽掉具体传送介质 和 物理设备的差异。</p>
<p>物理层上的传送单位，比特</p>
<p>透明比特流：经实际电路传送后没有发生变化。</p>
<p>特殊：0和1表示的电气特性及表示信号意义的逻辑特性</p>
<h2 id="以太网">以太网</h2>
<p>星型拓补结构局域网。</p>
<p>早期：使用集线器进行连接。</p>
<p>目前：使用交换机。交换机是一种数据链路层设备。</p>
<h2 id="ip-数据报">IP 数据报</h2>
<p>样式：首部 + 数据部分</p>
<p>首部：包含，版本（IP类型），首部长度，区分服务，总长度，生存时间，协议（TCP or UDP），首部校验和，标识，片偏移。</p>
<p>ARP 协议：地址解析协议 ARP</p>
<p>ARP 实现由 IP 地址获得 MAC 地址。</p>
<p>ARP 首先通过本地的 IP 到 MAC 地址的映射表查找。如果没有，则进行广播，搜索 IP 对应的 MAC 地址。</p>
<h2 id="imcp-协议国际控制报文协议-icmp">IMCP 协议：国际控制报文协议 ICMP</h2>
<p>ICMP 为了更有效转发 IP 数据和提高交付成功的机会。</p>
<p>它封装在 IP 数据报中。</p>
<p>ICMP 报文分为 差错报告报文和询问报文。</p>
<p>应用：Ping，测试主机之间的连通性；Traceroute，跟踪一个分组从源点到终点的路径。</p>
<h2 id="tcp-可靠传输">TCP 可靠传输：</h2>
<p>使用超时重传实现。</p>
<p>一个报文段从发送再到接收到确认所经过的时间称为 往返 RTT。</p>
<h2 id="tcp-拥塞控制">TCP 拥塞控制：</h2>
<p>网络拥塞，分组丢失，发送发继续重发，导致网络拥塞更严重。</p>
<p>当出现拥塞，应 控制发送发的速率。</p>
<p>流量控制：为了让接收方来得及接收；拥塞控制：为了降低整个网络的拥塞程度。</p>
<p>TCP 通过四个算法进行拥塞控制：慢开始，拥塞避免，快重传，快恢复。</p>
<p>此时，发送方需要维持一个 拥塞窗口(cwnd) 的状态变量。</p>
<h2 id="dns域名系统">DNS：域名系统</h2>
<p>分布式数据库，提供 主机名和 IP 地址之间相互交换的服务。分布式数据库：每个站点只保留它自己的那部分数据。</p>
<p>DNS 可使用 UDP or TCP 进行传输，使用  53 端口。</p>
<p>大多数情况使用 UDP，要求域名解析器和域名服务器处理自己的处理超时和重传保证可靠性。</p>
<p>使用 TCP 场景：返回的相应超过 512 字节。区域传送。</p>
<h2 id="ftp文本传输协议">FTP：文本传输协议</h2>
<p>使用 TCP 连接。<br>
需要两个连接传送一个文件：控制连接，数据连接。</p>
<p>控制连接使用 21 端口。</p>
<p>根据服务器的主动性，分为 主动和被动性。</p>
<p>主动，服务器端口 20 ，客户端随机，大于 1024</p>
<p>被动，客户端端口号自定义，服务端端口号随机。</p>
<p>被动性会导致服务端安全性减弱，因开放过多端口号。</p>
<hr>
<h2 id="http">HTTP</h2>
<h3 id="getpost-差异性">GET，POST 差异性：</h3>
<p>作用：GET 用于获取资源，POST 用于传送实体主体。</p>
<p>参数：GET 以查询字符串出现在 URL， POST 参数存储在实体主体中。</p>
<p>安全：GET是安全的，POST 会改变状态。（安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。）</p>
<p>幂等性：GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p>
<h3 id="可缓存性">可缓存性</h3>
<p>需要缓存，需满足：</p>
<p>1，请求报文的HTTP方法本身可以缓存，包括 GET 和 HEAD 方法，PUT 和 DELETE 不可缓存。POST 在大多数情况不能缓存。</p>
<p>2，相应报文的状态码可以缓存。</p>
<p>3，响应报文的 Cache-Control 首部字段没有指定。</p>
<h3 id="xmlhttprequest">XMLHttpRequest</h3>
<p>了解：XMLHttpRequest 是一个 API，它为客户端提供了 在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。<br>
1，在使用  XMLHttpRequest 的 POST ，浏览器会发送 Header 再发送 data，但并不是所有的浏览器都会这么做。<br>
2，GET 方法的 HEADER 和 Data 会一起发送。</p>
<p>状态码：服务器返回的响应报文中第一行为状态码。</p>
<p>1XX 信息<br>
2XX 成功<br>
3XX 重定向<br>
4XX 客户端错误<br>
5XX 服务器错误</p>
<h3 id="cookie">Cookie</h3>
<p>出现，HTTP/1.1，用来保存状态信息</p>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览之后向服务器再次发起请求时被携带上，用户告知服务器两个请求是否来自于同一浏览器。</p>
<p>新的浏览器已经允许开发者直接将数据存储到本地，如使用  Web storage API（本地存储和会话存储）或 IndexedDB。</p>
<p>1，用途：状态会话管理，个性化设置，浏览器行为跟踪。<br>
2，创建过程：服务器 响应报文包含 set-cookie 首部字段，客户端得到响应报文后把 Cookie 保存到浏览器中。<br>
3，分类：会话期 Cookie，持久性 Cookie<br>
4，作用域：Domain 标识指定哪些主机接收 Cookie<br>
5，JavaScript：通过 document.cookie 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。<br>
6，HttpOnly：标记为 HTTPOnly 的 Cookie 不能被 JavaScript 脚本调用。<br>
7，Secure：标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给给服务端。<br>
8，Session：利用 Session 将 cookie 存储在 服务器端，信息更加安全。也可以通过 Redis 存储 Session。<br>
9，浏览器禁用 Cookie：此时只能使用 Session，可以使用 URL 重写技术，将 Session 作为 URL 的参数进行传递。<br>
10，Cookie 和 Session 选择<br>
Cookie 只能存储 ASCii字符串，Session 可以存储任意类型，参考不同的场景；<br>
Cookie 存储在浏览器中，易被恶意查看。<br>
Session 开销大，不建议将所有的用户信息存储在 Session中。</p>
<h3 id="缓存">缓存</h3>
<p>1，优点：缓解服务器压力，降低客户端获取资源的延迟。<br>
2，实现方式：让代理人服务器继续缓存，让客户段进行缓存。<br>
3，Cache-Control：<br>
3.1：禁止进行缓存- no-store</p>
<p>3.2：强制确认缓存- no-cache</p>
<p>3.3：私有缓存和公共缓存- private || public</p>
<p>3.4：缓存过期机制- max-age=XXX || Expires：date</p>
<p>4，缓存验证<br>
ETag：资源的唯一标识。</p>
<p>If-None-Match：可以将缓存资源的值放入 If-None-Match ，判断于最新的 ETag 值是否一致。<br>
Last-Modified：弱校验器。ETag 的备用方法。</p>
<p>If-Modified-Since：客户端 带上 If-Modified-Since 验证缓存，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。</p>
<p>如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 Not Modified 响应。</p>
<h3 id="连接管理">连接管理</h3>
<p>1，长连接：只需要建立一次 TCP 连接就可进行多次 HTTP 通信。</p>
<ul>
<li>从 HTTP/1.1 开始默认是 长连接，如果要断开连接，要客户端 or 服务器端提出断开，使用 Connection : close；</li>
<li>在 HTTP/1.1 之前默认是 短连接，如果需要使用长连接，则使用 Connection : Keep-Alive。<br>
2，流水线：在同一条长连接上发出连续的请求，而不用等待响应返回，可以避免连接延迟。</li>
</ul>
<h3 id="加密">加密</h3>
<p>1，对称性加密：加密解密使用同一把锁。优：运算快。缺：无法安全传输。</p>
<p>2，非对称性加密：加密解密使用不同的锁。优：更安全公开密钥传输通信。缺：运算速度慢。</p>
<p>3，HTTPs 加密方式：混合加密。使用 非对称性密钥加密 传输 对称密钥（保证传输过程安全），使用 对称密钥 加密 进行 通信 （保证通信过程的效率）。</p>
<h3 id="认证使用-证书-对通信方-进行认证">认证：使用 证书 对通信方 进行认证。</h3>
<p>进行HTTPs 通信时，服务器把证书发送到客户端，客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，即可开始通信。</p>
<h3 id="完整性保护ssl-ssl-提供报文摘要来进行完整性保护">完整性保护：SSL。SSL 提供报文摘要来进行完整性保护。</h3>
<p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。</p>
<p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。</p>
<p>HTTPS 的缺点：需要进行加密解密过程，速度会减慢；需要支付证书授权的高额费用。</p>
<h3 id="http20">HTTP/2.0</h3>
<p>HTTP/1.X 缺陷<br>
HTTP/1.x 以牺牲性能为代价实现简单：客户端需要多个连接才能比并发和缩短延迟。不会压缩请求和响应首部，导致不必要的网络流量。不支持有效的资源优先级，使底层TCP连接利用率低下。</p>
<h3 id="二进制分帧层">二进制分帧层</h3>
<p>HTTP/2.0 将报文分成  HEADERS 帧 and DATA 帧，它们都是二进制帧。</p>
<p>通过过程只会有一个 TCP 连接，它承载着任意数量的双向数据流 STREAM。</p>
<ul>
<li>一个数据流都有一个唯一标识符 和 可选的优先级信息，用于承载双向信息。</li>
<li>消息，与 逻辑请求 or 响应对应的完整的一系列帧。</li>
<li>帧，最小的通信到位，不同数据流的帧可以交错发送，然后根据每个帧头数据流标识符重新组装。</li>
</ul>
<h3 id="服务器推送">服务器推送</h3>
<p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，这样，客户端不需要再次发起请求。</p>
<h3 id="首部压缩">首部压缩</h3>
<p>HTTP/1.0 首部带有大量信息，而且需要每次重复发送。</p>
<p>HTTP/2.0 要求客户端 和 服务器端 同时 维护 和 更新 一个包含之前见过的首部字段表，避免了重复传输。</p>
<p>HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p>
<p>HTTP 版本比较<br>
缺-</p>
<h3 id="socket">Socket</h3>
<p>I/O 模型：Unix五种。堵塞式 IO，非堵塞式 IO，IO 复用，信号驱动式 IO，异步 IO</p>
<p>套接字的输入操作：1，等待数据从网络到达。数据到达时，复制到内核中某个缓冲区。<br>
2，数据从内核缓冲区复制到应用进程缓冲区。</p>
<p>阻塞式 I/O</p>
<p>应用进程堵塞，直到数据从内核缓冲区复制到应用进程中才返回。当堵塞时，其他应用程序还能运行，且不占用 CPU 时间，CPU 利用效率高。</p>
<p>非阻塞式 I/O</p>
<p>应用程序执行系统调用，内核返回一个状态码。应用程序可以继续执行，但需要不断执行系统调用来获知 IO 是否完成（这种方式被称为 轮询，polling）。CPU 要处理更多系统调用，CPU 利用率低。</p>
<p>I/O 复用</p>
<p>使用 select 和 pull 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被堵塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核中复制到进程中。<br>
它可以让单个进程具有处理多个 IO 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。<br>
相比多线程，多进程，IO 复用不需要进程线程创建和切换的开销，系统开销更小。</p>
<p>信号驱动 I/O</p>
<p>应用程序使用 sigaction 系统调用，内核立即返回，应用程序可以继续执行，即，等待数据阶段应用程序是非堵塞的。内核在数据到达时，向应用程序发送 SIGIO 信号，应用程序收到后在信号处理程序中调用 revfrom 将数据 从内核复制到应用程序中。<br>
相比 非堵塞式 IO 的 轮询 Pull 方式，信号驱动 IO CPU 利用率更高。</p>
<p>异步 IO</p>
<p>应用程序执行 aio_read 系统调用会立即返回，应用程序可以继续执行，不会被堵塞，内核会在所有操作完成之后向应用程序发送信号。<br>
异步 I/O 与信号驱动 I/O 的区别：异步 I/O 的信号是 通知 应用进程 I/O 完成，而 信号驱动 I/O 的信号是 通知应用进程 可以 开始 I/O。</p>
<hr>
<p>多路复用</p>
<p>SELECT<br>
缺-<br>
POLL<br>
缺-</p>
]]></content>
    </entry>
</feed>